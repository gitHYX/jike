<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <link rel="stylesheet" type="text/css" href="css/index.css">
</head>

<body>
    <div class="container">
        <h1>高级前端面试总结</h1>
        <div class="html-css">
            <h2>HTML CSS部分</h2>
            <h3>1.对WEB标准以及W3C的理解与认识</h3>
            <div class="text">
                标签闭合、标签小写、不乱嵌套、提高搜索机器人搜索几率、使用外链css和js脚本、结构行为表现的分离、文件下载与页面速度更快、内容能被更多的用户所访问、内容能被更广泛的设备所访问、更少的代码和组件，容易维护、改版方便，不需要变动页面内容、提供打印版本而不需要复制内容、提高网站易用性;
            </div>
            <h3>
                <a href="http://blog.csdn.net/wnety/article/details/6577102" target="_blank">2.xhtml和html有什么区别</a>
            </h3>
            <div class="text">
                <p>
                    HTML是一种基本的WEB网页设计语言，XHTML是一个基于XML的置标语言
                    <br> 最主要的不同：
                    <br> XHTML 元素必须被正确地嵌套。
                    <br> XHTML 元素必须被关闭。
                    <br> 标签名必须用小写字母。
                    <br> XHTML 文档必须拥有根元素。
                </p>
            </div>
            <h3>
              <a href="http://www.jianshu.com/p/e6f9d5021583" target="_blank">3.Doctype? 严格模式与混杂模式-如何触发这两种模式，区分它们有何意义?</a>
            </h3>
            <div class="text">
                用于声明文档使用那种规范(html/Xhtml)一般为 严格 过度 基于框架的html文档加入XMl声明可触发，解析方式更改为IE5.5 拥有IE5.5的bug
            </div>
            <h3>4.行内元素有哪些?块级元素有哪些?CSS的盒模型?</h3>
            <div class="text">
                用于声明文档使用那种规范(html/Xhtml)一般为 严格 过度 基于框架的html文档加入XMl声明可触发，解析方式更改为IE5.5 拥有IE5.5的bug
                <p>
                    块级元素：div p h1 h2 h3 h4 form ul
                    <br> 行内元素: a b br i span input select
                    <br>
                    <a href="http://www.bbs0101.com/archives/98.html">Css盒模型</a>:内容，border ,margin，padding ,
                    <a href="http://blog.csdn.net/lovejulyer/article/details/51231951">弹性盒模型</a>
                    <br>
                    <a href="http://flexboxfroggy.com/">学习弹性盒模型的小游戏</a>
                </p>
                <a href="http://www.cnblogs.com/ChengWuyi/p/4718765.html">探讨行内元素转换为块级元素</a>
            </div>
            <h3>
                     <a href="http://blog.sina.com.cn/s/blog_81835d030100t117.html" target="_blank">5.CSS引入的方式有哪些?</a> &nbsp;&nbsp;&nbsp;&nbsp; <a href="http://www.jb51.net/web/71573.html" target="_blank">link和@import的区别是?</a>
                 </h3>
            <div class="text">
                <p>内联 内嵌 外链 导入
                    <br> 区别 ：同时加载
                    <br> 前者无兼容性，后者CSS2.1以下浏览器不支持
                </p>
                Link 支持使用javascript改变样式，后者不可
            </div>
            <h3>
                    <a href="http://www.cnblogs.com/dolphinX/p/3347713.html" target="_blank">6.CSS选择符有哪些?哪些属性可以继承?优先级算法如何计算?内联和important哪个优先级高?
                     </a>
                </h3>
            <div class="text">
                <p>标签选择符 类选择符 id选择符
                    <br> 继承不如指定 Id&gt;class&gt;标签选择</p>
                后者优先级高
            </div>
            <h3>7.前端页面有哪三层构成，分别是什么?作用是什么?</h3>
            <div class="text">
                结构层 Html 表示层 CSS 行为层 js
            </div>
            <h3>8.css的基本语句构成是?</h3>
            <div class="text">
                选择器{属性1:值1;属性2:值2;……}
            </div>
            <h3>9.你做的页面在哪些流览器测试过?这些浏览器的内核分别是什么?</h3>
            <div class="text">
                Ie(Ie内核) 火狐(Gecko) 谷歌(webkit) opear(Presto)
            </div>
            <h3>
                <a href="http://www.css88.com/book/css/experience/bugs.htm" target="_blank">10.写出几种IE6 BUG的解决方法</a>
            </h3>
            <div class="text">
                <p>1.双边距BUG float引起的 使用display
                    <br> 2.3像素问题 使用float引起的 使用dislpay:inline -3px
                    <br> 3.超链接hover 点击后失效 使用正确的书写顺序 link visited hover active
                    <br> 4.Ie z-index问题 给父级添加position:relative
                    <br> 5.Png 透明 使用js代码 改
                    <br> 6.Min-height 最小高度 !Important 解决’
                    <br> 7.select 在ie6下遮盖 使用iframe嵌套
                    <br> 8.为什么没有办法定义1px左右的宽度容器(IE6默认的行高造成的，使用over:hidden,zoom:0.08 line-height:1px)
                    <br> 9.ie 6 不支持!important</p>
            </div>
            <h3>11.img标签上title与alt属性的区别是什么??</h3>
            <div class="text">
                <p>Alt 当图片不显示是 用文字代表。
                    <br> Title 为该属性提供信息</p>
            </div>
            <h3>12.描述css reset的作用和用途。</h3>
            <div class="text">
                <p>Reset重置浏览器的css默认属性 浏览器的品种不同，样式不同，然后重置，让他们统一</p>
            </div>
            <h3>13.解释css sprites，如何使用。</h3>
            <div class="text">
                <p>Css 精灵 把一堆小的图片整合到一张大的图片上，减轻服务器对图片的请求数量</p>
            </div>
            <h3>14.浏览器标准模式和怪异模式之间的区别是什么?</h3>
            <div class="text">
                <p>盒子模型 渲染模式的不同
                    <br> 使用 window.top.document.compatMode 可显示为什么模式</p>
            </div>
            <h3>15.你如何对网站的文件和资源进行优化?期待的解决方案包括：</h3>
            <div class="text">
                <p>文件合并
                    <br> 文件最小化/文件压缩
                    <br> 使用CDN托管
                    <br> 缓存的使用
                </p>
            </div>
            <h3>16.什么是语义化的HTML?</h3>
            <div class="text">
                <p>直观的认识标签 对于搜索引擎的抓取有好处</p>
            </div>
            <h3>17.清除浮动的几种方式，各自的优缺点</h3>
            <div class="text">
                <p>1.使用空标签清除浮动 clear:both(理论上能清楚任何标签，，，增加无意义的标签)
                    <br> 2.使用overflow:auto(空标签元素清除浮动而不得不增加无意代码的弊端,,使用zoom:1用于兼容IE)
                    <br> 3.是用afert伪元素清除浮动(用于非IE浏览器)
                </p>
            </div>
            <h3>18.css hack</h3>
            <div class="text">
                <p>&lt;!--[if IE 6]--&gt;&lt;![end if]--&gt;
                    <br> _marging \\IE 6
                    <br> +margin \\IE 7
                    <br> Marging:0 auto \9 所有Ie
                    <br> Margin \0 \\IE 8</p>
            </div>
            <h3><a href="http://www.cnblogs.com/timelesszhuang/p/5323257.html" target="_blank">19.html5改良的input元素种类</a></h3>
        </div>
        <!-- html css end-->
        <div class="js">
            <h2>javascript</h2>
            <h4>1、使用 typeof bar === "object" 判断 bar 是不是一个对象有神马潜在的弊端？如何避免这种弊端？ </h4>
            <p>使用 typeof 的弊端是显而易见的(这种弊端同使用 instanceof )： </p>
            <pre class="brush:javascript; toolbar: true; auto-links: false;">
                let obj = {};
                let arr = [];
                console.log(typeof obj === 'object');  //true
                console.log(typeof arr === 'object');  //true
                console.log(typeof null === 'object');  //true
            </pre>
            <p>从上面的输出结果可知， typeof bar === "object" 并不能准确判断 bar 就是一个 Object。可以通过 Object.prototype.toString.call(bar) === "[object Object]" 来避免这种弊端： </p>
            <pre class="brush:javascript; toolbar: true; auto-links: false;">
                let obj = {};
                let arr = [];
                console.log(Object.prototype.toString.call(obj));  //[object Object]
                console.log(Object.prototype.toString.call(arr));  //[object Array]
                console.log(Object.prototype.toString.call(null));  //[object Null]</pre>
            <div>
                <p>另外，为了珍爱生命，请远离 == ： </p>
                <img class="alignCenter" src="img/20160103125015_394.png" width="602" height="297"> </div>
            <p>而 [] === false 是返回 false 的。 </p>
            <h4>2、下面的代码会在 console 输出神马？为什么？</h4>
            <pre class="brush:javascript; toolbar: true; auto-links: false;">
                (function(){
                     var a = b = 3;
                })();

                console.log("a defined? " + (typeof a !== 'undefined'));   
                console.log("b defined? " + (typeof b !== 'undefined'));</pre>
            <p>这跟变量作用域有关，输出换成下面的：</p>
            <pre>
                console.log(b); //3
                console,log(typeof a); //undefined
            </pre>
            <p>拆解一下自执行函数中的变量赋值：</p>
            <pre>b = 3;var a = b;</pre>
            <p>所以 b 成了全局变量，而 a 是自执行函数的一个局部变量。 </p>
            <h4>3、下面的代码会在 console 输出神马？为什么？</h4>
            <pre class="brush:javascript; toolbar: true; auto-links: false;">
                var myObject = {
                        foo: "bar",
                        func: function() {
                        var self = this;
                        console.log("outer func:  this.foo = " + this.foo);
                        console.log("outer func:  self.foo = " + self.foo);
                        (function() {
                            console.log("inner func:  this.foo = " + this.foo);
                            console.log("inner func:  self.foo = " + self.foo);
                            }());
                         }
                    };
                myObject.func();
            </pre>
            <p>第一个和第二个的输出不难判断，在 ES6 之前，JavaScript 只有函数作用域，所以 func 中的 IIFE 有自己的独立作用域，并且它能访问到外部作用域中的 self ，所以第三个输出会报错，因为 this 在可访问到的作用域内是 undefined ，第四个输出是 bar 。如果你知道闭包，也很容易解决的： </p>
            <pre class="brush:javascript; toolbar: true; auto-links: false;">
                (function(test) {
                    console.log("inner func:  this.foo = " + test.foo);  //'bar'
                    console.log("inner func:  self.foo = " + self.foo);
                    }(self));
            </pre>
            <p>如果对闭包不熟悉，可以戳此：从作用域链谈闭包 </p>
            <h4>4、将 JavaScript 代码包含在一个函数块中有神马意思呢？为什么要这么做？</h4>
            <p>换句话说，为什么要用立即执行函数表达式（Immediately-Invoked Function Expression）。</p>
            <p>IIFE 有两个比较经典的使用场景，一是类似于在循环中定时输出数据项，二是类似于 JQuery/Node 的插件和模块开发。</p>
            <pre class="brush:javascript; toolbar: true; auto-links: false;">
                for(var i = 0; i &lt; 5; i++) {
                    setTimeout(function() {
                     console.log(i);  
                    }, 1000);
                }
            </pre>
            <p>上面的输出并不是你以为的0，1，2，3，4，而输出的全部是5，这时 IIFE 就能有用了：</p>
            <pre class="brush:javascript; toolbar: true; auto-links: false;">
                for(var i = 0; i &lt; 5; i++) {
                    (function(i) {
                        setTimeout(function() {
                        console.log(i);  
                         }, 1000);
                    })(i)
                }
            </pre>
            <p>而在 JQuery/Node 的插件和模块开发中，为避免变量污染，也是一个大大的 IIFE：</p>
            <pre>
                (function($) { 
                    //代码
                } )(jQuery);
            </pre>
            <h4>5、在严格模式('use strict')下进行 JavaScript 开发有神马好处？</h4>
            <ul>
                <li>消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;</li>
                <li>消除代码运行的一些不安全之处，保证代码运行的安全；</li>
                <li>提高编译器效率，增加运行速度；</li>
                <li>为未来新版本的Javascript做好铺垫。</li>
            </ul>
            <h4>6、下面两个函数的返回值是一样的吗？为什么？</h4>
            <pre class="brush:javascript; toolbar: true; auto-links: false;">
                function foo1()
                    {
                        return {
                             bar: "hello"
                        };
                    }

                function foo2()
                    {
                        return {
                             bar: "hello"
                        };
                    }
            </pre>
            <p>在编程语言中，基本都是使用分号（;）将语句分隔开，这可以增加代码的可读性和整洁性。而在JS中，如若语句各占独立一行，通常可以省略语句间的分号（;），JS 解析器会根据能否正常编译来决定是否自动填充分号：</p>
            <pre>
                var test = 1 + 2
                console.log(test);  //3
            </pre>
            <p>在上述情况下，为了正确解析代码，就不会自动填充分号了，但是对于 return 、 break 、 continue 等语句，如果后面紧跟换行，解析器一定会自动在后面填充分号(;)，所以上面的第二个函数就变成了这样： </p>
            <pre>
                function foo2()
                    {
                        return;
                        {
                             bar: "hello"
                        };
                    }
            </pre>
            <p>所以第二个函数是返回 undefined 。 </p>
            <h4>7、神马是 NaN，它的类型是神马？怎么测试一个值是否等于 NaN?</h4>
            <p>NaN 是 Not a Number 的缩写，JavaScript 的一种特殊数值，其类型是 Number，可以通过 isNaN(param) 来判断一个值是否是 NaN ： </p>
            <pre class="brush:javascript; toolbar: true; auto-links: false;">
                console.log(isNaN(NaN)); //true
                console.log(isNaN(23)); //false
                console.log(isNaN('ds')); //true
                console.log(isNaN('32131sdasd')); //true
                console.log(NaN === NaN); //false
                console.log(NaN === undefined); //false
                console.log(undefined === undefined); //false
                console.log(typeof NaN); //number
                console.log(Object.prototype.toString.call(NaN)); //[object Number]
            </pre>
            <p>ES6 中， isNaN() 成为了 Number 的静态方法： Number.isNaN() . </p>
            <h4>8、解释一下下面代码的输出</h4>
            <pre class="brush:javascript; toolbar: true; auto-links: false;">
                console.log(0.1 + 0.2);   //0.30000000000000004
                console.log(0.1 + 0.2 == 0.3);  //false</pre>
            <p>JavaScript 中的 number 类型就是浮点型，JavaScript 中的浮点数采用IEEE-754 格式的规定，这是一种二进制表示法，可以精确地表示分数，比如1/2，1/8，1/1024，每个浮点数占64位。但是，二进制浮点数表示法并不能精确的表示类似0.1这样 的简单的数字，会有舍入误差。</p>
            <p>由于采用二进制，JavaScript 也不能有限表示 1/10、1/2 等这样的分数。在二进制中，1/10(0.1)被表示为 0.00110011001100110011…… 注意 0011 是无限重复的，这是舍入误差造成的，所以对于 0.1 + 0.2 这样的运算，操作数会先被转成二进制，然后再计算： </p>
            <pre class="brush:javascript; toolbar: true; auto-links: false;">0.1 =&gt; 0.0001 1001 1001 1001…（无限循环）0.2 =&gt; 0.0011 0011 0011 0011…（无限循环）</pre>
            <p>双精度浮点数的小数部分最多支持 52 位，所以两者相加之后得到这么一串 0.0100110011001100110011001100110011001100…因浮点数小数位的限制而截断的二进制数字，这时候，再把它转换为十进制，就成了 0.30000000000000004。</p>
            <p>对于保证浮点数计算的正确性，有两种常见方式。</p>
            <p>一是先升幂再降幂：</p>
            <pre class="brush:javascript; toolbar: true; auto-links: false;">
                function add(num1, num2){
                    let r1, r2, m;
                    r1 = (''+num1).split('.')[1].length;
                    r2 = (''+num2).split('.')[1].length;
                    m = Math.pow(10,Math.max(r1,r2));
                    return (num1 * m + num2 * m) / m;
                }
                console.log(add(0.1,0.2));   //0.3
                console.log(add(0.15,0.2256)); //0.3756
            </pre>
            <p>二是是使用内置的 toPrecision() 和 toFixed() 方法， <strong>注意，方法的返回值字符串。</strong> </p>
            <pre class="brush:javascript; toolbar: true; auto-links: false;">
                function add(x, y) {
                    return x.toPrecision() + y.toPrecision()
                }
                console.log(add(0.1,0.2));  //"0.10.2"</pre>
            <h4>9、实现函数 isInteger(x) 来判断 x 是否是整数 </h4>
            <p>可以将 x 转换成10进制，判断和本身是不是相等即可： </p>
            <pre>
                function isInteger(x) { 
                    return parseInt(x, 10) === x; 
                }
            </pre>
            <p>ES6 对数值进行了扩展，提供了静态方法 isInteger() 来判断参数是否是整数： </p>
            <pre class="brush:javascript; toolbar: true; auto-links: false;">
                Number.isInteger(25) // true
                Number.isInteger(25.0) // true
                Number.isInteger(25.1) // false
                Number.isInteger("15") // false
                Number.isInteger(true) // false</pre>
            <p>JavaScript能够准确表示的整数范围在 -2^53 到 2^53 之间（不含两个端点），超过这个范围，无法精确表示这个值。ES6 引入了 Number.MAX_SAFE_INTEGER 和 Number.MIN_SAFE_INTEGER 这两个常量，用来表示这个范围的上下限，并提供了 Number.isSafeInteger() 来判断整数是否是安全型整数。 </p>
            <h4>10、在下面的代码中，数字 1-4 会以什么顺序输出？为什么会这样输出？</h4>
            <pre class="brush:javascript; toolbar: true; auto-links: false;">
                (function() {
                    console.log(1); 
                    setTimeout(function(){console.log(2)}, 1000); 
                    setTimeout(function(){console.log(3)}, 0); 
                    console.log(4);
                })();
            </pre>
            <p>这个就不多解释了，主要是 JavaScript 的定时机制和时间循环，不要忘了，JavaScript 是单线程的。详解可以参考 <a href="http://www.cnblogs.com/zichi/p/4604053.html" rel="nofollow,noindex" target="_blank">从setTimeout谈JavaScript运行机制</a> 。 </p>
            <h4>11、写一个少于 80 字符的函数，判断一个字符串是不是回文字符串</h4>
            <pre class="brush:javascript; toolbar: true; auto-links: false;">
                function isPalindrome(str) {
                    str = str.replace(/\W/g, '').toLowerCase();
                    return (str == str.split('').reverse().join(''));
                }
            </pre>
            <p>这个题我在 codewars 上碰到过，并收录了一些不错的解决方式，可以戳这里： <a href="https://github.com/dwqs/awesome-codewars/blob/master/codewars/palindrome-for-your-dome.md" rel="nofollow,noindex" target="_blank">Palindrome For Your Dome</a> </p>
            <h4>12、写一个按照下面方式调用都能正常工作的 sum 方法</h4>
            <pre class="brush:javascript; toolbar: true; auto-links: false;">
                console.log(sum(2,3));   // Outputs 5
                console.log(sum(2)(3));  // Outputs 5
            </pre>
            <p>针对这个题，可以判断参数个数来实现：</p>
            <pre class="brush:javascript; toolbar: true; auto-links: false;">
                function sum() {
                    var fir = arguments[0];
                    if(arguments.length === 2) {
                        return arguments[0] + arguments[1]
                    } else {
                        return function(sec) {
                            return fir + sec;
                        }
                    }
   
                }
            </pre>
            <h4>13、根据下面的代码片段回答后面的问题</h4>
            <pre class="brush:javascript; toolbar: true; auto-links: false;">
                for (var i = 0; i &lt; 5; i++) {
                    var btn = document.createElement('button');
                    btn.appendChild(document.createTextNode('Button ' + i));
                    btn.addEventListener('click', function(){ console.log(i); });
                    document.body.appendChild(btn);
                }
            </pre>
            <div>
                <p>1、点击 Button 4 ，会在控制台输出什么？ </p>
                <p>2、给出一种符合预期的实现方式</p>
            </div>
            <div>
                <p>1、点击5个按钮中的任意一个，都是输出5</p>
                <p>2、参考 IIFE。</p>
            </div>
            <h4>14、下面的代码会输出什么？为什么？</h4>
            <pre class="brush:javascript; toolbar: true; auto-links: false;">
                var arr1 = "john".split(''); j o h n
                var arr2 = arr1.reverse(); n h o j
                var arr3 = "jones".split(''); j o n e s
                arr2.push(arr3);
                console.log("array 1: length=" + arr1.length + " last=" + arr1.slice(-1));
                console.log("array 2: length=" + arr2.length + " last=" + arr2.slice(-1));
            </pre>
            <p>会输出什么呢？你运行下就知道了，可能会在你的意料之外。</p>
            <p>MDN 上对于 reverse() 的描述是酱紫的： </p>
            <div>
                <div>
                    <p>Description</p>
                    <p>The reverse method transposes the elements of the calling array object in place, mutating the array, and returning a reference to the array.</p>
                </div>
            </div>
            <p>reverse() 会改变数组本身，并返回原数组的引用。 </p>
            <p>slice 的用法请参考： <a href="http://javascript.ruanyifeng.com/stdlib/string.html#toc6" rel="nofollow,noindex" target="_blank">slice</a> </p>
            <h4>15、下面的代码会输出什么？为什么？</h4>
            <pre class="brush:javascript; toolbar: true; auto-links: false;">
                console.log(1 +  "2" + "2");
                console.log(1 +  +"2" + "2");
                console.log(1 +  -"1" + "2");
                console.log(+"1" +  "1" + "2");
                console.log( "A" - "B" + "2");
                console.log( "A" - "B" + 2);</pre>
            <p>输出什么，自己去运行吧，需要注意三个点：</p>
            <ul>
                <li>多个数字和数字字符串混合运算时，跟操作数的位置有关</li>
            </ul>
            <pre class="brush:javascript; toolbar: true; auto-links: false;">
                console.log(2 + 1 + '3'); / /‘33’
                console.log('3' + 2 + 1); //'321'
            </pre>
            <ul>
                <li>数字字符串之前存在数字中的正负号(+/-)时，会被转换成数字</li>
            </ul>
            <pre class="brush:javascript; toolbar: true; auto-links: false;">
                console.log(typeof '3');   // string
                console.log(typeof +'3');  //number
            </pre>
            <p>同样，可以在数字前添加 '' ，将数字转为字符串 </p>
            <pre class="brush:javascript; toolbar: true; auto-links: false;">
                console.log(typeof 3);   // number
                console.log(typeof (''+3));  //string
            </pre>
            <ul>
                <li>对于运算结果不能转换成数字的，将返回 NaN </li>
            </ul>
            <pre class="brush:javascript; toolbar: true; auto-links: false;">
                console.log('a' * 'sd');   //NaN
                console.log('A' - 'B');  // NaN
            </pre>
            <p>这张图是运算转换的规则</p>
            <p><img class="alignCenter" src="img/20160103125016_698.png" width="700" height="570"> </p>
            <h4>16、如果 list 很大，下面的这段递归代码会造成堆栈溢出。如果在不改变递归模式的前提下修善这段代码？</h4>
            <pre class="brush:javascript; toolbar: true; auto-links: false;">
                var list = readHugeList();
                var nextListItem = function() {
                var item = list.pop();

                if (item) {
                     // process the list item...
                     nextListItem();
                     }
                };
            </pre>
            <p>原文上的解决方式是加个定时器：</p>
            <pre class="brush:javascript; toolbar: true; auto-links: false;">
                var list = readHugeList();
                var nextListItem = function() {
                var item = list.pop();

                if (item) {
                    // process the list item...
                         setTimeout( nextListItem, 0);
                     }
                };</pre>
            <p>解决方式的原理请参考第10题。</p>
            <h4>17、什么是闭包？举例说明</h4>
            <p>可以参考此篇：从作用域链谈闭包 </p>
            <h4>18、下面的代码会输出什么？为啥？</h4>
            <pre class="brush:javascript; toolbar: true; auto-links: false;">
                for (var i = 0; i &lt; 5; i++) {
                    setTimeout(function() { console.log(i); }, i * 1000 );
                }
            </pre>
            <p>请往前面翻，参考第4题，解决方式已经在上面了</p>
            <h4>19、解释下列代码的输出</h4>
            <pre class="brush:javascript; toolbar: true; auto-links: false;">
                console.log("0 || 1 = "+(0 || 1));
                console.log("1 || 2 = "+(1 || 2));
                console.log("0 &amp;&amp; 1 = "+(0 &amp;&amp; 1));
                console.log("1 &amp;&amp; 2 = "+(1 &amp;&amp; 2));</pre>
            <p>逻辑与和逻辑或运算符会返回一个值，并且二者都是短路运算符：</p>
            <ul>
                <li>逻辑与返回第一个是 false 的操作数 或者 最后一个是 true 的操作数 </li>
            </ul>
            <pre class="brush:javascript; toolbar: true; auto-links: false;">
                console.log(1 &amp;&amp; 2 &amp;&amp; 0);  //0
                console.log(1 &amp;&amp; 0 &amp;&amp; 1);  //0
                console.log(1 &amp;&amp; 2 &amp;&amp; 3);  //3</pre>
            <p>如果某个操作数为 false ，则该操作数之后的操作数都不会被计算 </p>
            <ul>
                <li>逻辑或返回第一个是 true 的操作数 或者 最后一个是 false 的操作数 </li>
            </ul>
            <pre class="brush:javascript; toolbar: true; auto-links: false;">
                console.log(1 || 2 || 0); //1
                console.log(0 || 2 || 1); //2
                console.log(0 || 0 || false); //false</pre>
            <p>如果某个操作数为 true ，则该操作数之后的操作数都不会被计算 </p>
            <p>如果逻辑与和逻辑或作混合运算，则逻辑与的优先级高：</p>
            <pre class="brush:javascript; toolbar: true; auto-links: false;">
                console.log(1 &amp;&amp; 2 || 0); //2
                console.log(0 || 2 &amp;&amp; 1); //1
                console.log(0 &amp;&amp; 2 || 1); //1</pre>
            <p>在 JavaScript，常见的 false 值： </p>
            <pre>0, '0', +0, -0, false, '',null,undefined,null,NaN</pre>
            <p>要注意 <strong>空数组([])</strong> 和 <strong>空对象({}):</strong> </p>
            <pre class="brush:javascript; toolbar: true; auto-links: false;">
                console.log([] == false) //true
                console.log({} == false) //false
                console.log(Boolean([])) //true
                console.log(Boolean({})) //true</pre>
            <p>所以在 if 中， [] 和 {} 都表现为 true ： </p>
            <p><img class="alignCenter" src="img/20160103125016_81.png" width="700" height="484"> </p>
            <h4>20、解释下面代码的输出</h4>
            <pre>console.log(false == '0')
                console.log(false === '0')
            </pre>
            <p>请参考前面第14题运算符转换规则的图。</p>
            <h4>21、解释下面代码的输出</h4>
            <pre class="brush:javascript; toolbar: true; auto-links: false;">
                var a={},
                b={key:'b'},
                c={key:'c'};

                a[b]=123;
                a[c]=456;

                console.log(a[b]);
            </pre>
            <p>输出是 456，参考原文的解释：</p>
            <div>
                <p>The reason for this is as follows: When setting an object property, JavaScript will implicitly stringify the parameter value. In this case, since b and c are both objects, they will both be converted to
                    <q>[object Object]</q> . As a result, a[b] anda[c] are both equivalent to a[
                    <q>[object Object]</q> ] and can be used interchangeably. Therefore, setting or referencing a[c] is precisely the same as setting or referencing a[b]. </p>
            </div>
            <h4>22、解释下面代码的输出</h4>
            <pre class="brush:javascript; toolbar: true; auto-links: false;">console.log((function f(n){return ((n &gt; 1) ? n * f(n-1) : n)})(10));</pre>
            <p>结果是10的阶乘。这是一个递归调用，为了简化，我初始化 n=5，则调用链和返回链如下：</p>
            <p><img class="alignCenter" src="img/20160103125017_437.png" width="372" height="78"> </p>
            <h4>23、解释下面代码的输出</h4>
            <pre class="brush:javascript; toolbar: true; auto-links: false;">
                (function(x) {
                     return (function(y) {
                      console.log(x);
                    })(2)
                })(1);
            </pre>
            <p>输出1，闭包能够访问外部作用域的变量或参数。</p>
            <h4>24、解释下面代码的输出，并修复存在的问题</h4>
            <pre class="brush:javascript; toolbar: true; auto-links: false;">
                var hero = {
                    _name: 'John Doe',
                     getSecretIdentity: function (){
                     return this._name;
                    }
                };

                var stoleSecretIdentity = hero.getSecretIdentity;

                console.log(stoleSecretIdentity());
                console.log(hero.getSecretIdentity());</pre>
            <p>将 getSecretIdentity 赋给 stoleSecretIdentity ，等价于定义了 stoleSecretIdentity 函数： </p>
            <pre class="brush:javascript; toolbar: true; auto-links: false;">
                var stoleSecretIdentity =  function (){
                    return this._name;
                }
            </pre>
            <p>stoleSecretIdentity 的上下文是全局环境，所以第一个输出 undefined 。若要输出 John Doe ，则要通过 call 、 apply 和 bind 等方式改变 stoleSecretIdentity 的 this 指向(hero)。 </p>
            <p>第二个是调用对象的方法，输出 John Doe 。 </p>
            <h4>25、给你一个 DOM 元素，创建一个能访问该元素所有子元素的函数，并且要将每个子元素传递给指定的回调函数。</h4>
            <p>函数接受两个参数：</p>
            <ul>
                <li>DOM</li>
                <li>指定的回调函数</li>
            </ul>
            <p>原文利用 <a href="https://en.wikipedia.org/wiki/Depth-first_search" rel="nofollow,noindex" target="_blank">深度优先搜索</a> (Depth-First-Search) 给了一个实现： </p>
            <pre class="brush:javascript; toolbar: true; auto-links: false;">
                function Traverse(p_element,p_callback) {
                    p_callback(p_element);
                    var list = p_element.children;
                     for (var i = 0; i &lt; list.length; i++) {
                        Traverse(list[i],p_callback);  // recursive call
                    }
                }
            </pre>
        </div>
        <!-- js end -->
    </div>
</body>

</html>
